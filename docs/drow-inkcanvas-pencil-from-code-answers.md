# 「Drow to InkCanvas with Pencil Strokes from code.md」の質問への回答

この文書は、`Drow to InkCanvas with Pencil Strokes from code.md` 内の「私「…」」の質問に対し、現時点で妥当な前提（本リポジトリの方針を含む）で回答を整理したものです。

> 注: 会話ログには誤情報が含まれます（例: `InkToolbar.GetInkingAttributes()`、`PencilProperties.Hardness` を確実に操作できる前提、`StrokeContainer.SaveAsync` を画像保存として扱う等）。本回答はそれらに依存しません。

---

## Q1. 「UWPの`InkCanvas`上に`InkToolbar`の鉛筆を使った`InkStroke`をコードで描画したい」

- `InkStroke` は `InkStrokeBuilder` で生成し、`InkCanvas.InkPresenter.StrokeContainer.AddStroke(...)` に追加すると表示されます。
- 鉛筆風の属性は `InkDrawingAttributes.CreateForPencil()` をベースにし、太さや色は取得できる範囲で `InkToolbar` 側の選択を反映します。
- `InkToolbar` の「現在選択値」を `InkDrawingAttributes` として一括取得できるAPIは前提にしない方針が安全です。本リポジトリでは鉛筆ボタンからベストエフォートで拾います。

---

## Q2. 「描画のサンプルを取りたい。筆圧などを任意の値で一定条件で作成したい」

- 点ごとの筆圧を固定/変化させたい場合は、`InkPoint`（座標＋pressure）を並べて `InkStrokeBuilder.CreateStrokeFromInkPoints(...)` を使うのが適しています。
- 例: pressure を `0.2 / 0.5 / 0.8 / 1.0` のようなプリセットにして並べると、比較用サンプルとして再現性が高くなります。

---

## Q3. 「`InkToolbar`設定を取得し、硬さだけを10段階に変えて、重ならないようにループ描画できる？」

- 「重ならないようにループ描画」は可能です（Y座標をずらす、spacingを取る）。
- ただし、`InkToolbar` から属性を一括取得するAPI（`GetInkingAttributes`）や、`PencilProperties.Hardness` を確実に変更できる前提は置かないのが安全です。
- 本リポジトリでは Hardness の代わりに Pressure を段階化し、同一条件で比較可能なシートを作る方針です。

---

## Q4. 「テキストラベルは良い。解像度はどうなっている？」

- `InkCanvas` の表示座標は DIPs（Device Independent Pixels）で扱われ、デバイスDPIやスケールにより見え方が変わります。
- 画像としての「解像度（ピクセルサイズ）」を固定したい場合は、`InkCanvas` の見た目をそのまま保存するのではなく、別のレンダリングターゲットに描画してピクセル画像を生成する必要があります。

---

## Q5. 「一番変質しないのはbitmap？画像を高解像度で出力したい」

- 劣化（不可逆圧縮）を避けたいなら用途的には PNG（ロスレス）が一般的です。
- 高解像度出力は、Win2D の `CanvasRenderTarget(width, height, dpi)` に `DrawInk(strokes)` で描き、`SaveAsync(..., CanvasBitmapFileFormat.Png)` で保存する方式が実装しやすいです。
- `InkPresenter.StrokeContainer.SaveAsync` は画像ではなく、インクデータの保存用途です（PNG保存にはなりません）。

---

## Q6. 「取得したサンプルを他の描画アプリでサンプリングして、スタンプやテクスチャとして使用したい」

- 目的として妥当です。
- 使い回し前提なら、少なくとも以下があると運用しやすいです。
  - 透明背景の素材用PNG（線のみ）
  - 白背景＋条件ラベル焼き込みの確認用PNG
  - 余白（切り出しやすさ）と一定の配置規則

---

## Q7. 「10段階の硬さサンプルから、3.52相当を3と4のサンプルから作れる？」

- 画像としてのサンプルを「重ね合わせ（アルファ合成）」して中間値を作ることは可能ですが、物理的な『硬さ』の挙動を再現している保証はありません（見た目近似になります）。
- もし “任意パラメータで再現” が必要なら、画像補間ではなく、描画時パラメータで再生成できる仕組み（レンダラ/ブラシモデル）を別途設計する方が筋が良いです。
- 本リポジトリの範囲（Ink→PNGサンプル生成）では、Hardness ではなく Pressure 段階化で比較可能なデータを作ります。

---

## Q8. 「描画エンジンが作れるのならその方がよい」

- そもそも “InkCanvasの鉛筆” を他環境で完全再現するのは、内部実装（粒子/テクスチャ/ブレンド）の詳細が公開されていないため、一般には困難です。
- 現実的には「目標の見た目」を定義し、
  - ブラシ先端（tip）の画像・ノイズ（紙目）
  - pressure に応じたサイズ/濃度/密度の変化
  - 合成ルール（重ね塗りの挙動）
  を設計して再現することになります。

---

## Q9. 「筆圧の変化は、基準があれば濃さ（透明度？）を変えることで対応できる？」

- 透明度だけで筆圧差を表現することは可能ですが、鉛筆らしさ（粒子密度/かすれ/太さ変化）まで含めると不十分になりがちです。
- 最低限のモデルとしては、
  - pressure → 不透明度（濃さ）
  - pressure → ブラシサイズ（太さ）
  を組み合わせるのが一般的です。

---

## Q10. 「『基準データ』を`InkCanvas`からどう抽出し、どう処理する？」

- 本リポジトリの範囲では「基準データ抽出して独自エンジンへ移植」より、まず `InkStroke`（ベクタ）を高解像度でPNG化して比較素材を作るのが主目的です。
- もし抽出をやるなら、概念的には
  - 同条件で生成したストロークを多数レンダリング
  - 得られたピクセル（alpha/輝度）統計を取り、分布や密度を評価
  のような工程になります。

---

## Q11. 「基準テクスチャをどう作る？描画速度は？」

- 厳密な意味での“基準テクスチャ”作成は、独自レンダラの設計領域です。
- 描画速度については、ピクセル単位の処理をCPUで全面実行すると重くなりがちなので、
  - GPUでの合成（シェーダ/ブレンド）
  - 影響範囲（ストローク周辺の小領域）に限定
  - 事前生成（キャッシュ）
  などが典型的な方針になります。

---

## Q12. 「描画中に硬度は変わらない」

- パラメータがストローク中に固定なら、
  - ストローク開始時に必要なリソース（tip/マスク/キャッシュ）を作り
  - 描画中はそれを使い回す
  といった設計が取りやすくなります。

---

## Q13. 「スタンプ方式で、移動後は“重ならない差分だけ”塗ることは可能？」

- 差分領域を幾何的に計算して塗ることも理屈上は可能ですが、一般にはコストや実装複雑性が上がります。
- 実務では「既に塗られているピクセルは上書きしない」や「MAX/飽和合成」など、合成ルールで“結果として差分だけ増える”挙動を作る方が多いです。

---

## Q14. 「描画処理と同時にマスクをかけるのは現実的に難しい？」

- “マスクを更新しながら描画する” 自体は現実的です。
- ただし、マスクの更新を毎回CPUで全画面処理するのではなく、更新範囲を限定したり、GPUのブレンド/ステンシル等の機構に寄せるのが一般的です。

---

## Q15. 「実際の鉛筆のように、一度塗ったところも通ると重ねて塗られるなら、マスクを消す処理が必要？」

- 「一切重ならない」挙動を作るマスクを採用しているなら、重ね塗りをしたい場合は“完全に禁止”ではなく
  - 上限付き加算（saturate）
  - 時間/距離に応じた緩和
  などのルールに変える必要があります。

---

## Q16. 「不透明度の再計算コストはどの程度？」

- 全画面全ピクセルを毎フレームCPUで再計算すると重くなりがちです。
- 一方で、更新範囲をブラシ周辺の小領域に限定できるなら、CPUでも現実的な場合があります。
- GPUのブレンド/合成に寄せられるなら、一般にはパフォーマンス上かなり有利です。

